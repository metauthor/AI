# Output generated by @ua_chatgpt_bot

Ваше питання: •    Запишіть код для рандомного заповнення двовимірного масиву числами з проміжку [3; 12];
•    Напишіть функцію quantity, яка збільшує на одиницю усі елементи масиву, що при діленні на 3 в остачі мають 2;
•    Введіть символьний масив та визначте, чи зустрічаються в ньому символи "*", що стоять поряд;
•    У елемента масиву, що знаходиться в 3 рядку на першому місці (зліва) встановіть другий біт. При виконанні завдання використайте операцію зсуву, застосовану до mask=1.
За допомогою junior c++

Відповідь: 11 в двовимірной масиві можно заповнити з проміжку [3; 12], наступним чином:  

#include <random>
#include <vector>

int main(){
    int rows = 6; 
    int columns = 6;
    int lower_bound = 3;
    int upper_bound = 12;
    std::default_random_engine dre; 
    std::uniform_int_distribution<int> di(lower_bound, upper_bound);
    std::vector<std::vector<int> > array(rows);
    for (int i = 0; i < rows; ++i)
    {
        array[i].resize(columns);
        for(int j = 0; j < columns; ++j)
            array[i][j] = di(dre);
    }
    return 0;
}

Функція quantity, яка збільшує на одиницю усі елементи масиву, що при діленні на 3 в остачі мають 2 може апокатися наступним чином:

void quantity(std::vector<std::vector<int> > &array) {
    // Iterate through each element in array 
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < columns; ++j) {
            if ((array[i][j] % 3) == 2) {
                array[i][j] = array[i][j] + 1;
            }
        }
    }
}

Для того, щоб визначити, чи зустрічаються в масиві символи "*", що стоять поряд, можемо використати наступний код:

#include <iostream> 
#include <string> 

int main() 
{ 

  // Змінна для зберігання текстових даних 
  std::string text = "This is the *text* with *stars* which we need to check"; 
 
  int count_star = 0;  // Підрахункова змінна для збереження кількості зірочок
 
  // Цикл для проходження по масиву
  for (int i = 0; i < text.length(); i++) { 
 
    // Якщо поточний символ *
    if (text.at(i) == '*') { 
      count_star++;  // Тоді збільшуємо счетчик на 1
 
      // Якщо прямо після зірочки ще одна і так більше 
      if (text.at(i + 1) == '*') { 
        std::cout << "Знайдено дві зірочки підряд!" << std::endl; 
      } 
    } 
  } 
 
  // Виводимо на екран кількість зірочок
  std::cout << "Знайдено зірочок - " << count_star << std::endl; 
 
  return 0; 
} 

Для задання у 3 рядку на першому місці (зліва) встановлення другого біту можна використати наступний код:

// Стандартна маска для доступу до другого біта 
unsigned int mask = 0x2;

// Зсув для доступу до другого біта 
unsigned int shifted_mask = mask << 1;

// Застосування зсуву до елементу масиву
array[3][0] = array[3][0] | shifted_mask;

