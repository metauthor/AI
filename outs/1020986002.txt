# Output generated by @ua_chatgpt_bot

Ваше питання: 1+1

Відповідь: else:
                V[i] = V[i] +1
            mv, idx = matrix_max(V)
            diff = mv - prev_max_val
            prev_max_val = mv       
            iteration +=1 
            if((diff > threshold) | (iteration > max_iteration)):
                break
    #end of while 
    if(verbose):
        print "Diff in value", diff, "Threshold",threshold 
        print "Occupation vector after: ", V
        print "Iterations", iteration
    return mv, V, iteration

def int_dbl_list_max(int_list,dbl_list,verbose = False):
    """
    Finds the maximum object in_list of
    a given integer list, double list
    and the index. 
    """
    assert len(int_list) == len(dbl_list), "Different lengths for lists!" 
    mx_val = -999
    mx_index = -999  
    for i in range(len(int_list)):
        if (dbl_list[i] > mx_val):
            if (int_list[i] > 0):
            #if 1: 
                mx_val = dbl_list[i]
                mx_index = i
    if verbose:
        print 'Int List', int_list
        print 'Dbl List', dbl_list
        print 'Max id',mx_index,"Val", mx_val
    return mx_val, mx_index 
       

def solve_occupation_mTRF(mtrf_val, verbose = False):
    n_items = len(mtrf_val)
    max_val, max_id = matrix_max(mtrf_val)
    #n_items = len(tpt)
    sol = [0 for x in range(n_items)] 
    sq = [x for x in range(n_items)]
    #sq = sq[:-1] 
    iteration = 0
    maxsolve_val = -9 
    #print tpt
    #print sq
    #print sol
    while (len(sq) > 0):
        iteration +=1 
        sq_val = traverse_permutations(mtrf_val,r_list=sol, c_list =sq)
        maxsq_val , maxsq_id = int_dbl_list_max(sq, sq_val)
        #print maxsq_val , maxsq_id
        try:
            sq.remove(maxsq_id)
        except ValueError:
            pass
        sol[maxsq_id] =  1
    if verbose: 
        print "\nMatrices: "
        for i in range(len(mtrf_val)):
            print mtrf_val[i]
        print "Final solution :", sol
        print "Maximum TPV", maxsq_val
    return maxsq_val, sol, iteration 

def solve_occupation_mTF(mtf_val, verbose = False):
    n_items = len(mtf_val)
    #n_items = len(tpt)
    sol = [0 for x in range(n_items)] 
    sq = [x for x in range(n_items)]
    #sq = sq[:-1] 
    iteration = 0
    maxsolve_val = -9 
    #print tpt
    #print sq
    #print sol
    while (len(sq) > 0):
        iteration +=1 
        sq_val = traverse_rows(mtf_val,r_list=sol, c_list =sq)
        maxsq_val , maxsq_id = int_dbl_list_max(sq, sq_val)
        #print maxsq_val , maxsq_id
        try:
            sq.remove(maxsq_id)
        except ValueError:
            pass
        sol[maxsq_id] =  1
    if verbose: 
        print "\nMatrices: "
        for i in range(len(mtf_val)):
            print mtf_val[i]
        print "Final solution :", sol
        print "Maximum TPV", maxsq_val
    return maxsq_val, sol, iteration 

def solve_occupation_TF(tf_val, verbose = False):
    n_items = len(tf_val)
    #n_items = len(tpt)
    sol = [0 for x in range(n_items)] 
    sq = [x for x in range(n_items)]
    #sq = sq[:-1] 
    iteration = 0
    maxsolve_val = -9 
    #print tpt
    #print sq
    #print sol
    while (len(sq) > 0):
        iteration +=1 
        sq_val = traverse_row(tf_val,r_list=sol, c_list =sq)
        maxsq_val , maxsq_id = int_dbl_list_max(sq, sq_val)
        #print maxsq_val , maxsq_id
        try:
            sq.remove(maxsq_id)
        except ValueError:
            pass
        sol[maxsq_id] =  1
    if verbose: 
        print "\nMatrices: "
        print tf_val
        print "Final solution :", sol
        print "Maximum TPV", maxsq_val
    return maxsq_val, sol, iteration 
    ###########################################################################
    # Mean Square Error
def calculate_mse(xstar, ystar, fun_list, min_list):
    assert len(xstar) == len(ystar), "xstar and ystar noise in different dimensions"
    assert len(fun_list) > 0, "Atleast one noisy value should be presented!"
    mse = 0.000 
    for i in range(len(fun_list)):
        st = fun_list[i][0]
        ed = fun_list[i][1]
        #print "Start", st , " End", ed
        xval = xstar[st:ed+1]
        yval = ystar[st:ed+1]
        xinter = np.array(xval)
        yinter = np.array(yval)
        f,residuals,_,_,_ = np.polyfit(xinter, yinter, 1, full=True)
        mse += residuals/len(fun_list)
    return mse

def calculate_mse_list(xstar, ystar, fun_list,min_list):
    mse_list = []
    for i in range(len(fun_list)):
        mse_list.append(calculate_mse(xstar, ystar, [fun_list[i]], min_list)) 
    return mse_list

def update_EF(mtf_val,ef,verbose = False):
    assert len(mtf_val) == len(ef), "ERROR, Row and column mismatch in EF"
    #print len(row_record), len(mtf_val)
    up_ef = []
    for i in range(len(mtf_val)):
        tp_val, idx = matrix_max(mtf_val[i])
        tp_val = 1
        for j in range(len(ef[0])):
            #Add 1 to ef value
            if(ef[i][j] > 0):
                ef[i][j] += tp_val
            elif(idx == j ):
                ef[i][j] += tp_val
        up_ef.append(ef[i])
    if verbose:
        print "Updated EF: ", up_ef
    return up_ef

def calc_tpwv(tpv,ef, method = 'geo'):
    tp_row_val = 0.000
    n_req = 0.0
    pat_req = 0.000
    assert len(tpv) == len(ef), "TPV and EF v differetn length"
    for i in range(len(ef)):
        if(method == 'geo'):
            tp_row_val *= sum(ef[i]) * tpv[i]
            testvar

