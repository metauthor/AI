# Output generated by @ua_chatgpt_bot

Ваше питання: Напиши на C++ функцию, которая реализовывает алгоритм flood fill на двумерном массиве bool и делает это не рекурсивно.

Відповідь: #include <iostream>
#include <vector>

using namespace std;

void FloodFill(vector<vector<bool>>& vec, int row, int col, bool target){

int ecol = vec[row].size();

vector<vector<bool>> done;
vector<pair<int,int>> stack;

stack.push_back(pair<int,int>(row,col));

while(!stack.empty()){ 
  pair<int,int> coords = stack.back();
  stack.pop_back();
  done.push_back( vector<bool>(ecol, false) );
 
  done[coords.first][coords.second]=true;
 
  if(vec[coords.first][coords.second] != target)
    vec[coords.first][coords.second] = target;

if(coords.first > 0 && !done[coords.first-1][coords.second] && vec[coords.first-1][coords.second] != target)
    stack.push_back(pair<int,int>(coords.first-1,coords.second));

if(coords.first < vec.size()-1 && !done[coords.first+1][coords.second] && vec[coords.first+1][coords.second] != target)
    stack.push_back(pair<int,int>(coords.first+1, coords.second));

if(coords.second > 0 && !done[coords.first][coords.second-1] && vec[coords.first][coords.second-1] != target)
    stack.push_back(pair<int,int>(coords.first,coords.second-1));

if(coords.second < ecol-1 && !done[coords.first][coords.second+1] && vec[coords.first][coords.second+1] != target)
    stack.push_back(pair<int,int>(coords.first, coords.second+1));

}

}

int main(){

  //usage example
  vector<vector<bool>> vec = { {false, false, false}, 
                              {false, true, false}, 
                              {false, false, false} };
  FloodFill(vec, 1,1, false);

for(int i=0; i<vec.size();i++){
  for(int j=0; j<vec[i].size();j++){
    cout << vec[i][j] << " ";
  }
  cout << endl;
}

return 0;
}

