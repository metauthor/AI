# Output generated by @ua_chatgpt_bot

Ваше питання: Create java documentation for this methods which represent endpoints in DishService class 
@Service
public class DishService {

    private final DishRepository dishRepository;
    private final ProductRepository productRepository;
    private final ProductToDishService productToDishService;
    private final UserService userService;

    @Autowired
    public DishService(
            DishRepository dishRepository,
            ProductRepository productRepository,
            ProductToDishService productToDishService,
            UserService userService
    ) {
        this.dishRepository = dishRepository;
        this.productRepository = productRepository;
        this.productToDishService = productToDishService;
        this.userService = userService;
    }

    public List<Dish> getAllDishes(String userLogin, Integer page) {
        Long userId = userService.getUser(userLogin).getId();
        Pageable pageable = PageRequest.of(page, Constants.ITEMS_PER_PAGE);
        return dishRepository.getDishes(pageable, userId);
    }

    public DishWithProductsDto getDishInfo(String userLogin, Long id) {
        Long userId = userService.getUser(userLogin).getId();
        return dishRepository.getDishById(id, userId).map(dish -> {
            List<Product> products = productToDishService.getAllByDish(dish).stream()
                    .map(ProductToDish::getProduct)
                    .toList();
            return new DishWithProductsDto(products, dish);
        }).orElseThrow(() -> new RuntimeException("Dish not found"));
    }

    public List<Dish> getAvailableDishes(String userLogin) {
        Long userId = userService.getUser(userLogin).getId();
        List<Long> userProductIds = productRepository.getUserProducts(userId).stream()
                .map(Product::getId)
                .toList();
        return dishRepository.getDishesWithALlProducts(userId, userProductIds);
    }

    @Transactional(rollbackFor = Exception.class)
    public Dish insertDish(DishDto dishDto, List<ProductWithMeasureDto> productsWithMeasures) {
        Dish dish = dishRepository.save(mapToEntity(dishDto));
        List<ProductToDish> productToDishes = productsWithMeasures.stream()
                .map(productWithMeasure -> new ProductToDish()
                        .setDish(dish)
                        .setProduct(ProductService.mapToEntity(productWithMeasure.getProduct()))
                        .setMeasure(productWithMeasure.getMeasure()))
                .toList();
        productToDishService.saveAll(productToDishes);
        return dish;
    }

    @Transactional(rollbackFor = Exception.class)
    public void deleteDish(String userLogin, Long dishId) {
        User user = userService.getUser(userLogin);
        if(user.getCustomDishes().stream().map(Dish::getId).noneMatch(id -> Objects.equals(id, dishId))) {
            throw new RuntimeException("User's dishes not contain selected dish");
        }
        dishRepository.deleteById(dishId);
    }

    public List<Dish> getCustomDishes(
            SortingOption sortingOption,
            DishSortBy dishSortBy,
            String userLogin,
            Integer page
    ) {
        Long userId = userService.getUser(userLogin).getId();
        Sort sort = switch (sortingOption) {
            case ASCENDING -> Sort.by(dishSortBy.getSortBy()).ascending();
            case DESCENDING -> Sort.by(dishSortBy.getSortBy()).descending();
        };
        Pageable pageable = PageRequest.of(page, Constants.ITEMS_PER_PAGE, sort);
        return dishRepository.getCustomDishes(pageable, userId);
    }

    public List<Dish> saveAll(List<Dish> entities) {
        return dishRepository.saveAll(entities);
    }

    public void deleteAll(List<Dish> entities) {
        dishRepository.deleteAll(entities);
    }

    public void deleteAll() {
        dishRepository.deleteAll();
    }

Відповідь: private Dish mapToEntity(DishDto dishDto) {
        return new Dish()
                .setName(dishDto.getName())
                .setServing(dishDto.getServing())
                .setDescription(dishDto.getDescription());
    }

}

/**
* getAllDishes
* 
* Gets all dishes. Filters them by user login to get user's personal dishes only.
* 
* @param userLogin A String for the user's login.
* @param page Integer for the page number.
* @return A list of dishes.
*/
public List<Dish> getAllDishes(String userLogin, Integer page);

/**
* getDishInfo
* 
* Gets dish info. Includes all products from that dish.
* 
* @param userLogin A String for the user's login.
* @param id A Dish.id.
* @return DishWithProductsDto object that contains Dish object and a List of products from dish.
*/
public DishWithProductsDto getDishInfo(String userLogin, Long id);

/**
* getAvailableDishes
* 
* Gets all dishes that user can create with his own ingredients. 
* 
* @param userLogin A String for the user's login.
* @return A list of dishes.
*/
public List<Dish> getAvailableDishes(String userLogin);

/**
* insertDish
* 
* Inserts a dish with its ingredients.
* 
* @param dishDto A DishDto object.
* @param productsWithMeasures A list of ProductWithMeasureDto elements.
* @return Inserted dish. 
*/
public Dish insertDish(DishDto dishDto, List<ProductWithMeasureDto> productsWithMeasures);

/**
* deleteDish
* 
* Deletes dish with all its ingredients.
* 
* @param userLogin A String for the user's login.
* @param dishId Dish.id Long element.
*/
public void deleteDish(String userLogin, Long dishId);

/**
* getCustomDishes
* 
* Gets custom dishes. Includes SortingOption and DishSortBy parameters.
* 
* @param sortingOption An enum SortingOption. Can be either ASCENDING or DESCENDING.
* @param dishSortBy An enum DishSortBy. Can be either BY_NAME or BY_CREATION_DATE.
* @param userLogin A String for the user's login.
* @param page Integer for the page number.
* @return A list of dishes.
*/
public List<Dish> getCustomDishes(SortingOption sortingOption, DishSortBy dishSortBy, String userLogin, Integer page);

/**
* saveAll
* 
* Saves all given dishes.
* 
* @param entities A list of Dish elements.
* @return A list of saved dishes.
*/
public List<Dish> saveAll(List<Dish> entities);

/**
* deleteAll
* 
* Deletes all given dishes.
* 
* @param entities A list of Dish elements.
*/
public void deleteAll(List<Dish> entities);

/**
* deleteAll
* 
* Deletes all dishes.
*/
public void deleteAll();

/**
* mapToEntity
* 
* Maps dish dto to dish entity.
* 
* @param dishDto A Dish element.
* @return Dish entity.
*/
private Dish mapToEntity(DishDto dishDto);

